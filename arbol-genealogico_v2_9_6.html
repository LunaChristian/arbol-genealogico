<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de √Årboles Geneal√≥gicos</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600&family=Work+Sans:wght@400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #2c3e50;
            --secondary: #34495e;
            --accent: #c0392b;
            --light: #ecf0f1;
            --white: #ffffff;
            --border: #bdc3c7;
        }
        
        body {
            font-family: 'Work Sans', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e8eef3 100%);
            height: 100vh;
            padding: 20px;
            margin: 0;
            overflow: hidden; /* Prevenir scroll en body */
            box-sizing: border-box;
        }
        
        .container {
            max-width: 1600px;
            width: 100%;
            height: calc(100vh - 40px); /* Restar padding del body */
            margin: 0 auto;
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 30px;
            overflow: hidden; /* Prevenir scroll en el contenedor principal */
        }
        
        .panel {
            background: var(--white);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 20px;
            height: 100%; /* Ocupa toda la altura del grid */
        }
        
        /* Panel izquierdo: scroll normal */
        .panel:first-child {
            overflow-y: auto;
        }
        
        /* Panel derecho (√°rbol): flex layout sin overflow */
        .panel:last-child {
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        h1 {
            font-family: 'Crimson Pro', serif;
            font-size: 1.8em;
            color: var(--primary);
            margin-bottom: 25px;
            font-weight: 600;
        }
        
        h2 {
            font-family: 'Crimson Pro', serif;
            font-size: 1.8em;
            color: var(--primary);
            margin-bottom: 20px;
            border-bottom: 3px solid var(--accent);
            padding-bottom: 10px;
            flex-shrink: 0; /* No se comprime en flex containers */
        }
        
        .subtitle {
            color: var(--secondary);
            margin-bottom: 30px;
            font-size: 0.95em;
        }
        
        .form-group {
            margin-bottom: 14px;
        }
        
        label {
            display: block;
            margin-bottom: 4px;
            color: var(--secondary);
            font-weight: 500;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-family: 'Work Sans', sans-serif;
            font-size: 0.95em;
            transition: all 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(192, 57, 43, 0.1);
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-family: 'Work Sans', sans-serif;
            font-weight: 600;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: var(--accent);
            color: white;
            width: 100%;
            margin-top: 8px;
        }
        
        .btn-primary:hover {
            background: #a93226;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(192, 57, 43, 0.3);
        }
        
        .btn-secondary {
            background: var(--secondary);
            color: white;
            margin-right: 10px;
        }
        
        .btn-secondary:hover {
            background: var(--primary);
        }
        
        .btn-export {
            background: #27ae60;
            color: white;
        }
        
        .btn-export:hover {
            background: #229954;
        }
        
        .btn-small {
            padding: 5px 10px;
            font-size: 0.8em;
            margin-left: 10px;
        }
        
        .person-list {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .person-item {
            background: var(--light);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 4px solid var(--accent);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .person-item:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .btn-delete {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.75em;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .person-item:hover .btn-delete {
            opacity: 1;
        }
        
        .btn-delete:hover {
            background: #c0392b;
        }
        
        .person-name {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 5px;
        }
        
        .person-details {
            font-size: 0.85em;
            color: var(--secondary);
        }
        
        .tree-canvas {
            width: 100%;
            flex: 1; /* Ocupa todo el espacio restante en el flex container */
            min-height: 0; /* Permite que flex shrink funcione correctamente */
            position: relative;
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden; /* Sin scroll - √°rbol se ajusta con zoom */
        }
        
        .tree-canvas-inner {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%); /* Centrado por defecto, se ajustar√° con scale en JS */
            transform-origin: center center;
            transition: transform 0.3s ease;
        }
        
        .tree-node {
            position: absolute;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 12px 15px;
            min-width: 220px;
            max-width: 220px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 0.85em;
        }
        
        .tree-node-name {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 8px;
            font-size: 1.05em;
            font-family: 'Crimson Pro', serif;
            text-align: center;
            text-transform: uppercase;
        }
        
        .tree-node-detail {
            color: var(--secondary);
            margin: 2px 0;
            font-size: 0.88em;
            line-height: 1.4;
        }
        
        svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
        }
        
        .tree-node {
            z-index: 1;
        }
        
        .actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        .tree-actions {
            margin-top: 15px;
            display: flex;
            gap: 12px;
            flex-shrink: 0;
            padding-top: 15px;
            border-top: 2px solid var(--light);
        }
        
        .helper-text {
            background: #fff9e6;
            border-left: 4px solid #f39c12;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #7f6a00;
        }
        
        .matrimonios-container {
            margin-top: 6px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .matrimonio-item {
            display: flex;
            gap: 10px;
            margin-bottom: 6px;
            align-items: end;
        }
        
        .matrimonio-item input {
            flex: 1;
        }
        
        /* V2.9.4: Validaci√≥n de errores */
        input.error {
            border-color: #e74c3c;
            background-color: #fadbd8;
        }
        
        .error-message {
            color: #e74c3c;
            font-size: 0.85em;
            margin-top: 4px;
            display: none;
        }
        
        .error-message.active {
            display: block;
        }
        
        /* V2.9.4: Bot√≥n X para eliminar matrimonios */
        .btn-remove-marriage {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            align-self: flex-end;
        }
        
        .btn-remove-marriage:hover {
            background: #c0392b;
            transform: scale(1.05);
        }
        
        @media print {
            * {
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }
            
            /* NO especificar @page - dejar que usuario configure */
            
            body {
                background: white;
                margin: 0;
                padding: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
            }
            
            /* Ocultar panel de entrada */
            .panel:first-child {
                display: none !important;
            }
            
            /* Contenedor centrado */
            .container {
                display: flex;
                align-items: center;
                justify-content: center;
                margin: 0;
                padding: 0;
            }
            
            /* Panel centrado */
            .panel {
                box-shadow: none;
                border: none;
                border-radius: 0;
                padding: 0;
                margin: 0;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Ocultar t√≠tulo */
            .panel h2 {
                display: none !important;
            }
            
            /* Canvas con dimensiones expl√≠citas para modo print */
            .tree-canvas {
                border: none;
                border-radius: 0;
                overflow: visible;
                page-break-inside: avoid;
                page-break-after: avoid;
                background: transparent;
                position: relative; /* Para que absolute del inner funcione */
                width: 100vw;
                height: 100vh;
                min-width: 100vw;
                min-height: 100vh;
            }
            
            /* Inner centrado manualmente para consistencia */
            .tree-canvas-inner {
                position: absolute;
                left: 50%;
                top: 50%;
                transform-origin: center center;
                /* transform aplicado din√°micamente por exportToPDF() con translate + scale */
            }
            
            /* Nodos no se cortan */
            .tree-node {
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Panel de entrada de datos -->
        <div class="panel">
            <h1>üìã √Årbol Geneal√≥gico</h1>
            
            <form id="personForm">
                <div class="form-group">
                    <label>Nombre Completo *</label>
                    <input type="text" id="nombre" required placeholder="Ej: Juan Carlos P√©rez">
                </div>
                
                <div class="form-group">
                    <label>Nacimiento</label>
                    <div class="matrimonio-item">
                        <div style="flex: 1;">
                            <input type="text" id="fechaNac" placeholder="Fecha (15/03/1950)">
                            <div id="errorFechaNac" class="error-message"></div>
                        </div>
                        <div style="flex: 1;">
                            <input type="text" id="lugarNac" placeholder="Lugar (Buenos Aires)">
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Matrimonios</label>
                    <div class="matrimonios-container" id="matrimoniosContainer">
                        <!-- V2.9.4: Matrimonios se crean din√°micamente aqu√≠ -->
                    </div>
                    <button type="button" class="btn btn-secondary btn-small" onclick="agregarMatrimonio()">+ Agregar Matrimonio</button>
                </div>
                
                <div class="form-group">
                    <label>Fecha de Defunci√≥n</label>
                    <input type="text" id="fechaDef" placeholder="Dejar vac√≠o si vive">
                    <div id="errorFechaDef" class="error-message"></div>
                </div>
                
                <div class="form-group">
                    <label>Relaci√≥n Familiar</label>
                    <select id="relacion">
                        <option value="">Ninguna (Persona inicial)</option>
                        <option value="padre">Es padre/madre de...</option>
                        <option value="hijo">Es hijo/a de...</option>
                    </select>
                </div>
                
                <div class="form-group" id="relacionPersonaGroup" style="display: none;">
                    <label>¬øDe qui√©n?</label>
                    <select id="relacionPersona">
                        <option value="">Seleccionar persona...</option>
                    </select>
                </div>
                
                <button type="submit" class="btn btn-primary">+ Agregar Persona</button>
                <button type="button" class="btn btn-secondary" onclick="cancelarEdicion()" id="btnCancelar" style="display:none; width:100%; margin-top:10px;">Cancelar Edici√≥n</button>
            </form>
            
            <div class="person-list" id="personList"></div>
        </div>
        
        <!-- Panel del √°rbol -->
        <div class="panel">
            <h2>Vista previa</h2>
            <div class="tree-canvas" id="treeCanvas">
                <div class="tree-canvas-inner" id="treeCanvasInner">
                    <svg id="linesSvg"></svg>
                </div>
            </div>
            
            <div class="tree-actions">
                <button class="btn btn-secondary" onclick="clearAll()">üóëÔ∏è Limpiar Todo</button>
                <button class="btn btn-export" onclick="exportToPDF()">üìÑ Exportar PDF</button>
            </div>
        </div>
    </div>

    <script>
        let personas = [];
        let nextId = 1;
        let nextMatrimonioId = 1; // V2.9.4: ID √∫nico para matrimonios din√°micos
        let editandoId = null;
        
        const NODE_WIDTH = 220;
        const NODE_HEIGHT = 180; // V2.9.4: Aumentado de 80 a 180 para matrimonios m√∫ltiples
        const V_GAP = 20; // V2.9.4: Aumentado de 8 a 20 para mejor separaci√≥n
        const H_SPACING = 10; // Gap horizontal entre hermanos normales
        const H_SPACING_COMPACT = 5; // Gap extra-compacto (hermano con hijos seguido de hoja)
        const H_SPACING_SIBLINGS = 30; // Gap entre hermanos cuando ambos tienen hijos
        const MARGIN = 50;
        
        // V2.9.4: Agregar matrimonio din√°micamente (SIN l√≠mite)
        function agregarMatrimonio() {
            const id = nextMatrimonioId++;
            const container = document.getElementById('matrimoniosContainer');
            
            const div = document.createElement('div');
            div.className = 'matrimonio-item';
            div.id = `matrimonio${id}`;
            
            div.innerHTML = `
                <div style="flex: 1;">
                    <input type="text" id="mat${id}_fecha" placeholder="Fecha (DD/MM/AAAA)">
                    <div id="errorMat${id}_fecha" class="error-message"></div>
                </div>
                <div style="flex: 1;">
                    <input type="text" id="mat${id}_conyuge" placeholder="Nombre del c√≥nyuge">
                </div>
                <button type="button" class="btn-remove-marriage" onclick="eliminarMatrimonio(${id})">‚úï</button>
            `;
            
            container.appendChild(div);
        }
        
        // V2.9.4: Eliminar matrimonio del DOM
        function eliminarMatrimonio(id) {
            const elemento = document.getElementById(`matrimonio${id}`);
            if (elemento) {
                elemento.remove();
            }
        }
        
        // V2.9.4: FUNCIONES DE VALIDACI√ìN DE FECHAS
        
        function validateDateFormat(dateStr) {
            if (!dateStr || dateStr.trim() === '') return { valid: true };
            
            const regex = /^(\d{2})\/(\d{2})\/(\d{4})$/;
            const match = dateStr.match(regex);
            
            if (!match) {
                return { valid: false, error: 'Formato debe ser DD/MM/AAAA' };
            }
            
            const day = parseInt(match[1], 10);
            const month = parseInt(match[2], 10);
            const year = parseInt(match[3], 10);
            
            if (month < 1 || month > 12) {
                return { valid: false, error: 'Mes inv√°lido (1-12)' };
            }
            
            if (day < 1 || day > 31) {
                return { valid: false, error: 'D√≠a inv√°lido (1-31)' };
            }
            
            const daysInMonth = new Date(year, month, 0).getDate();
            if (day > daysInMonth) {
                const monthNames = ['', 'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 
                                  'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
                return { valid: false, error: `${monthNames[month]} solo tiene ${daysInMonth} d√≠as` };
            }
            
            return { valid: true };
        }
        
        function parseDate(dateStr) {
            const result = validateDateFormat(dateStr);
            if (!result.valid || !dateStr) return null;
            
            const match = dateStr.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
            const day = parseInt(match[1], 10);
            const month = parseInt(match[2], 10);
            const year = parseInt(match[3], 10);
            
            return new Date(year, month - 1, day);
        }
        
        function validateDatesLogic(fechaNac, matrimonios, fechaDef) {
            const errors = {};
            
            const birthDate = parseDate(fechaNac);
            const deathDate = parseDate(fechaDef);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            if (deathDate && deathDate > today) {
                errors.fechaDef = 'La fecha de defunci√≥n no puede ser futura';
            }
            
            if (birthDate && deathDate && birthDate >= deathDate) {
                errors.fechaDef = 'Debe ser posterior a la fecha de nacimiento';
            }
            
            const marriageDates = [];
            matrimonios.forEach((mat) => {
                if (mat.fecha) {
                    const matDate = parseDate(mat.fecha);
                    if (matDate) {
                        marriageDates.push({ id: mat.id, date: matDate });
                        
                        if (birthDate && matDate < birthDate) {
                            errors[`mat${mat.id}_fecha`] = 'Debe ser posterior a la fecha de nacimiento';
                        }
                        
                        if (deathDate && matDate > deathDate) {
                            errors[`mat${mat.id}_fecha`] = 'No puede ser posterior a la fecha de defunci√≥n';
                        }
                    }
                }
            });
            
            for (let i = 0; i < marriageDates.length - 1; i++) {
                if (marriageDates[i].date >= marriageDates[i + 1].date) {
                    errors[`mat${marriageDates[i + 1].id}_fecha`] = 'Los matrimonios deben estar en orden cronol√≥gico';
                }
            }
            
            return errors;
        }
        
        function showErrors(errors) {
            clearErrors();
            
            for (const [field, message] of Object.entries(errors)) {
                const input = document.getElementById(field);
                const errorDiv = document.getElementById(`error${field.charAt(0).toUpperCase() + field.slice(1)}`);
                
                if (input && errorDiv) {
                    input.classList.add('error');
                    errorDiv.textContent = message;
                    errorDiv.classList.add('active');
                }
            }
        }
        
        function clearErrors() {
            document.querySelectorAll('.error').forEach(el => el.classList.remove('error'));
            document.querySelectorAll('.error-message').forEach(el => {
                el.classList.remove('active');
                el.textContent = '';
            });
        }
        

        // V2.9.9: Normalizaci√≥n de nombres y lugares
        function normalizeWhitespace(s) {
            return (s || '').replace(/\s+/g, ' ').trim();
        }

        function toTitleCaseWords(s) {
            s = normalizeWhitespace(s);
            if (!s) return '';
            const lowerWords = new Set(['de','del','la','las','los','y','e','da','do','di','du','van','von']);
            return s.split(' ').map((w, i) => {
                const clean = w.replace(/[^\p{L}\p{N}'\-\.]/gu, '');
                if (!clean) return w;
                const lw = clean.toLowerCase();
                if (i > 0 && lowerWords.has(lw)) return lw;
                // Si est√° todo en may√∫sculas y es corto (ej: USA), lo preservamos
                if (clean.length <= 4 && clean === clean.toUpperCase()) return clean;
                return lw.charAt(0).toUpperCase() + lw.slice(1);
            }).join(' ');
        }

        function normalizePersonName(name) {
            // Mantiene ap√≥strofes y guiones; title case.
            return toTitleCaseWords(name);
        }

        function normalizeSpouseName(name) {
            return toTitleCaseWords(name);
        }

        function normalizePlace(place) {
            place = normalizeWhitespace(place);
            if (!place) return '';
            // Normaliza por segmentos separados por coma
            const parts = place.split(',').map(p => toTitleCaseWords(p));
            return parts.join(', ');
        }

        function updateRelacionSelect() {
            const select = document.getElementById('relacionPersona');
            select.innerHTML = '<option value="">Seleccionar persona...</option>';
            
            personas.forEach(p => {
                const option = document.createElement('option');
                option.value = p.id;
                option.textContent = p.nombre;
                select.appendChild(option);
            });
        }
        
        function updateRelacionOptions() {
            const relacionSelect = document.getElementById('relacion');
            const ningunaOption = relacionSelect.querySelector('option[value=""]');
            
            if (personas.length === 0) {
                // √Årbol vac√≠o: solo permitir "Ninguna"
                ningunaOption.disabled = false;
                ningunaOption.selected = true;
                relacionSelect.querySelectorAll('option[value="padre"], option[value="hijo"]').forEach(opt => {
                    opt.disabled = true;
                });
            } else {
                // Hay personas: NO permitir "Ninguna", obligar a seleccionar relaci√≥n
                ningunaOption.disabled = true;
                relacionSelect.querySelectorAll('option[value="padre"], option[value="hijo"]').forEach(opt => {
                    opt.disabled = false;
                });
                
                // Si est√° seleccionada "Ninguna", cambiar a la primera opci√≥n disponible
                if (relacionSelect.value === '') {
                    relacionSelect.value = 'padre'; // Seleccionar por defecto
                    // Trigger change event para mostrar el select de persona
                    relacionSelect.dispatchEvent(new Event('change'));
                }
            }
        }
        
        // V1.5: Funci√≥n para verificar si una persona es ancestro de otra
        function esAncestro(posibleAncestroId, personaId) {
            // Verifica si posibleAncestro est√° en la cadena de ancestros de persona
            const persona = personas.find(p => p.id === personaId);
            
            if (!persona) return false;
            if (persona.padres.length === 0) return false;
            
            // Si el padre directo es el posible ancestro, retornar true
            if (persona.padres.includes(posibleAncestroId)) {
                return true;
            }
            
            // Buscar recursivamente en los ancestros del padre
            for (const padreId of persona.padres) {
                if (esAncestro(posibleAncestroId, padreId)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // V1.5: Verificar integridad del √°rbol (detectar ciclos)
        function verificarIntegridadArbol() {
            // Verificar que ninguna persona sea ancestro de s√≠ misma
            for (const persona of personas) {
                if (esAncestro(persona.id, persona.id)) {
                    return {
                        valido: false,
                        personaEnCiclo: persona.nombre
                    };
                }
            }
            return { valido: true };
        }
        
        document.getElementById('relacion').addEventListener('change', function(e) {
            const group = document.getElementById('relacionPersonaGroup');
            group.style.display = e.target.value ? 'block' : 'none';
        });
        
        document.getElementById('personForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            // V2.9.4: Limpiar errores previos
            clearErrors();
            
            // V2.9.4: Obtener valores
            const fechaNac = document.getElementById('fechaNac').value.trim();
            const fechaDef = document.getElementById('fechaDef').value.trim();
            
            // V2.9.4: Obtener matrimonios din√°micamente
            const matrimoniosConId = [];
            const matrimonioElements = document.querySelectorAll('#matrimoniosContainer .matrimonio-item');
            matrimonioElements.forEach(elem => {
                const id = elem.id.replace('matrimonio', '');
                const fechaInput = document.getElementById(`mat${id}_fecha`);
                const conyugeInput = document.getElementById(`mat${id}_conyuge`);
                
                if (fechaInput && conyugeInput) {
                    const fecha = fechaInput.value.trim();
                    const nombreConyuge = conyugeInput.value.trim();
                    
                    if (fecha || nombreConyuge) {
                        matrimoniosConId.push({ id: id, fecha, nombreConyuge });
                    }
                }
            });
            
            // V2.9.4: Validar formatos de fecha
            const errors = {};
            
            const fechaNacResult = validateDateFormat(fechaNac);
            if (!fechaNacResult.valid) {
                errors.fechaNac = fechaNacResult.error;
            }
            
            const fechaDefResult = validateDateFormat(fechaDef);
            if (!fechaDefResult.valid) {
                errors.fechaDef = fechaDefResult.error;
            }
            
            matrimoniosConId.forEach(mat => {
                if (mat.fecha) {
                    const result = validateDateFormat(mat.fecha);
                    if (!result.valid) {
                        errors[`mat${mat.id}_fecha`] = result.error;
                    }
                }
            });
            
            if (Object.keys(errors).length > 0) {
                showErrors(errors);
                return;
            }
            
            // V2.9.4: Validar l√≥gica de fechas
            const logicErrors = validateDatesLogic(fechaNac, matrimoniosConId, fechaDef);
            if (Object.keys(logicErrors).length > 0) {
                showErrors(logicErrors);
                return;
            }
            
            // V2.9.4: Limpiar campo id antes de guardar (solo era para validaci√≥n)
            const matrimonios = matrimoniosConId.map(m => ({ fecha: m.fecha, nombreConyuge: normalizeSpouseName(m.nombreConyuge) }));
            
            if (editandoId !== null) {
                const persona = personas.find(p => p.id === editandoId);
                persona.nombre = normalizePersonName(document.getElementById('nombre').value);
                persona.fechaNac = document.getElementById('fechaNac').value;
                persona.lugarNac = normalizePlace(document.getElementById('lugarNac').value);
                persona.matrimonios = matrimonios;
                persona.fechaDef = document.getElementById('fechaDef').value;
                
                cancelarEdicion();
                updatePersonList(); // V2.9.4: Actualizar lista
                drawTree(); // V2.9.4: Redibujar √°rbol
            } else {
                // VALIDACI√ìN V1.2: Relaci√≥n obligatoria despu√©s de la primera persona
                const relacion = document.getElementById('relacion').value;
                const relacionPersonaId = parseInt(document.getElementById('relacionPersona').value);
                
                if (personas.length > 0 && (!relacion || !relacionPersonaId)) {
                    alert('‚ùå ERROR: Debe relacionar esta persona con alguien del √°rbol existente.\n\nSeleccione "Es padre/madre de..." o "Es hijo/a de..." y elija la persona correspondiente.');
                    return;
                }
                
                const persona = {
                    id: nextId++,
                    nombre: normalizePersonName(document.getElementById('nombre').value),
                    fechaNac: document.getElementById('fechaNac').value,
                    lugarNac: normalizePlace(document.getElementById('lugarNac').value),
                    matrimonios: matrimonios,
                    fechaDef: document.getElementById('fechaDef').value,
                    padres: [],
                    hijos: []
                };
                
                if (relacion && relacionPersonaId) {
                    const relacionPersona = personas.find(p => p.id === relacionPersonaId);
                    
                    // V1.5: Prevenir ciclos geneal√≥gicos
                    // NOTA: Con el flujo actual (agregar personas nuevas sin relaciones previas),
                    // esta validaci√≥n no se activar√°, pero est√° aqu√≠ para protecci√≥n futura.
                    
                    // Verificar que no se cree un ciclo
                    // La validaci√≥n real se har√° agregando temporalmente la persona
                    // y verificando la integridad del √°rbol
                    
                    if (relacion === 'padre') {
                        // persona ser√° padre de relacionPersona
                        // NO debe haber ciclo: relacionPersona no debe ser ancestro de persona
                        // Como persona es nueva (no en el array a√∫n), no tiene ancestros
                        // Por lo tanto, relacionPersona nunca ser√° ancestro de persona
                        // Esta verificaci√≥n est√° aqu√≠ por documentaci√≥n
                    } else if (relacion === 'hijo') {
                        // persona ser√° hijo de relacionPersona
                        // NO debe haber ciclo: persona no debe ser ancestro de relacionPersona
                        // Como persona es nueva, no puede ser ancestro de nadie
                        // Esta verificaci√≥n est√° aqu√≠ por documentaci√≥n
                    }
                    
                    // V1.4: Validar m√°ximo 1 padre por persona
                    if (relacion === 'padre') {
                        // La nueva persona ser√° padre de relacionPersona
                        // Verificar que relacionPersona no tenga ya un padre
                        if (relacionPersona.padres.length > 0) {
                            const padreExistente = personas.find(p => p.id === relacionPersona.padres[0]);
                            const nombrePadreExistente = padreExistente ? padreExistente.nombre : 'Desconocido';
                            
                            alert(`‚ùå ERROR: "${relacionPersona.nombre}" ya tiene un padre/madre asignado.\n\nPadre/Madre existente: ${nombrePadreExistente}\n\nüí° Regla: En este √°rbol cada persona puede tener como M√ÅXIMO 1 padre/madre.`);
                            return;
                        }
                        
                        relacionPersona.padres.push(persona.id);
                        persona.hijos.push(relacionPersonaId);
                        
                    } else if (relacion === 'hijo') {
                        // La nueva persona ser√° hijo de relacionPersona
                        // La nueva persona siempre empieza sin padres, pero verificamos por seguridad
                        if (persona.padres.length > 0) {
                            const padreExistente = personas.find(p => p.id === persona.padres[0]);
                            const nombrePadreExistente = padreExistente ? padreExistente.nombre : 'Desconocido';
                            
                            alert(`‚ùå ERROR: "${persona.nombre}" ya tiene un padre/madre asignado.\n\nPadre/Madre existente: ${nombrePadreExistente}\n\nüí° Regla: En este √°rbol cada persona puede tener como M√ÅXIMO 1 padre/madre.`);
                            return;
                        }
                        
                        relacionPersona.hijos.push(persona.id);
                        persona.padres.push(relacionPersonaId);
                    }
                }
                
                personas.push(persona);
                
                // V1.5: Verificar integridad del √°rbol despu√©s de agregar
                const integridad = verificarIntegridadArbol();
                if (!integridad.valido) {
                    // ROLLBACK: Remover la persona reci√©n agregada
                    personas.pop();
                    
                    // Limpiar relaciones que se hayan agregado
                    if (relacion && relacionPersonaId) {
                        const relacionPersona = personas.find(p => p.id === relacionPersonaId);
                        if (relacionPersona) {
                            if (relacion === 'padre') {
                                relacionPersona.padres = relacionPersona.padres.filter(id => id !== persona.id);
                            } else if (relacion === 'hijo') {
                                relacionPersona.hijos = relacionPersona.hijos.filter(id => id !== persona.id);
                            }
                        }
                    }
                    
                    alert(`‚ùå ERROR: No se puede agregar a "${persona.nombre}".\n\nSe detect√≥ un ciclo geneal√≥gico que involucra a "${integridad.personaEnCiclo}".\n\nüí° Un ciclo ocurre cuando una persona ser√≠a ancestro y descendiente de s√≠ misma, lo cual no est√° permitido en √°rboles geneal√≥gicos.`);
                    return;
                }
                
                e.target.reset();
                document.getElementById('matrimoniosContainer').innerHTML = ''; // V2.9.4: Limpiar matrimonios din√°micos
            }
            
            updatePersonList();
            updateRelacionSelect();
            updateRelacionOptions(); // V1.2: Actualizar estado de opciones de relaci√≥n
            drawTree();
        });
        
        function updatePersonList() {
            const list = document.getElementById('personList');
            list.innerHTML = '';
            
            personas.forEach(p => {
                const item = document.createElement('div');
                item.className = 'person-item';
                item.innerHTML = `
                    <div class="person-name">‚úèÔ∏è ${p.nombre}</div>
                    <div class="person-details">
                        ${p.fechaNac ? `Nac: ${p.fechaNac}` : ''}
                        ${p.fechaDef ? ` - Def: ${p.fechaDef}` : ''}
                    </div>
                    <button class="btn-delete" onclick="event.stopPropagation(); eliminarPersona(${p.id})">üóëÔ∏è</button>
                `;
                item.onclick = () => editarPersona(p.id);
                list.appendChild(item);
            });
        }
        
        function eliminarPersona(id) {
            // V3.1: Verificar si la persona tiene descendientes
            const persona = personas.find(p => p.id === id);
            
            if (!persona) {
                alert('‚ùå ERROR: No se encontr√≥ la persona a eliminar.');
                return;
            }
            
            if (persona.hijos.length > 0) {
                // Obtener nombres de los hijos para mostrar en el mensaje
                const nombresHijos = persona.hijos
                    .map(hijoId => {
                        const hijo = personas.find(p => p.id === hijoId);
                        return hijo ? hijo.nombre : 'Desconocido';
                    })
                    .join(', ');
                
                alert(`‚ùå ERROR: No se puede eliminar a "${persona.nombre}" porque tiene descendientes.\n\nDescendientes: ${nombresHijos}\n\nüí° Sugerencia: Elimine primero a los descendientes y luego intente nuevamente.`);
                return;
            }
            
            // V3.2: Confirmar eliminaci√≥n
            if (!confirm(`¬øEst√°s seguro de eliminar a "${persona.nombre}"?\n\nEsta acci√≥n no se puede deshacer.`)) return;
            
            personas.forEach(p => {
                p.hijos = p.hijos.filter(hijoId => hijoId !== id);
                p.padres = p.padres.filter(padreId => padreId !== id);
            });
            
            personas = personas.filter(p => p.id !== id);
            
            if (editandoId === id) {
                cancelarEdicion();
            }
            
            updatePersonList();
            updateRelacionSelect();
            updateRelacionOptions(); // V1.2: Actualizar estado de opciones de relaci√≥n
            drawTree();
        }
        
        function editarPersona(id) {
            const persona = personas.find(p => p.id === id);
            if (!persona) return;
            
            editandoId = id;
            
            document.getElementById('nombre').value = persona.nombre;
            document.getElementById('fechaNac').value = persona.fechaNac || '';
            document.getElementById('lugarNac').value = persona.lugarNac || '';
            document.getElementById('fechaDef').value = persona.fechaDef || '';
            
            // V2.9.4: Limpiar contenedor de matrimonios
            document.getElementById('matrimoniosContainer').innerHTML = '';
            
            // V2.9.4: Cargar matrimonios din√°micamente
            persona.matrimonios.forEach(mat => {
                const id = nextMatrimonioId++;
                const container = document.getElementById('matrimoniosContainer');
                
                const div = document.createElement('div');
                div.className = 'matrimonio-item';
                div.id = `matrimonio${id}`;
                
                div.innerHTML = `
                    <div style="flex: 1;">
                        <input type="text" id="mat${id}_fecha" placeholder="Fecha (DD/MM/AAAA)" value="${mat.fecha || ''}">
                        <div id="errorMat${id}_fecha" class="error-message"></div>
                    </div>
                    <div style="flex: 1;">
                        <input type="text" id="mat${id}_conyuge" placeholder="Nombre del c√≥nyuge" value="${mat.nombreConyuge || ''}">
                    </div>
                    <button type="button" class="btn-remove-marriage" onclick="eliminarMatrimonio(${id})">‚úï</button>
                `;
                
                container.appendChild(div);
            });
            
            document.querySelector('.btn-primary').textContent = '‚úì Actualizar Persona';
            document.getElementById('btnCancelar').style.display = 'block';
            document.getElementById('relacion').parentElement.style.display = 'none';
            document.getElementById('relacionPersonaGroup').style.display = 'none';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        function cancelarEdicion() {
            editandoId = null;
            document.getElementById('personForm').reset();
            document.getElementById('matrimoniosContainer').innerHTML = ''; // V2.9.4: Limpiar matrimonios din√°micos
            document.querySelector('.btn-primary').textContent = '+ Agregar Persona';
            document.getElementById('btnCancelar').style.display = 'none';
            document.getElementById('relacion').parentElement.style.display = 'block';
            clearErrors(); // V2.9.4: Limpiar errores
        }
        
        // ALGORITMO DE √ÅRBOL CORREGIDO
        function drawTree() {
            const canvas = document.getElementById('treeCanvas');
            const canvasInner = document.getElementById('treeCanvasInner');
            const svg = document.getElementById('linesSvg');
            
            console.log('drawTree() llamado, personas:', personas.length);
            
            // Limpiar canvas inner
            const nodesToRemove = [];
            for (let i = 0; i < canvasInner.children.length; i++) {
                const child = canvasInner.children[i];
                if (child.id !== 'linesSvg') {
                    nodesToRemove.push(child);
                }
            }
            nodesToRemove.forEach(node => node.remove());
            svg.innerHTML = '';
            
            if (personas.length === 0) {
                console.log('No hay personas para mostrar');
                return;
            }
            
            // Encontrar ra√≠z
            let raiz = personas.find(p => p.padres.length === 0);
            if (!raiz) raiz = personas[0];
            
            const layout = {};
            const depthMap = {};
            
            // NUEVO ALGORITMO: Calcular ancho considerando compactaci√≥n de hermanos sin hijos
            function calcularAncho(id) {
                const p = personas.find(n => n.id === id);
                if (!p) return NODE_WIDTH;
                
                // Si no tiene hijos, solo ocupa su propio ancho
                if (p.hijos.length === 0) return NODE_WIDTH;
                
                // Si tiene hijos, calcular ancho con compactaci√≥n inteligente
                let total = 0;
                for (let i = 0; i < p.hijos.length; i++) {
                    const childId = p.hijos[i];
                    const child = personas.find(n => n.id === childId);
                    const childWidth = calcularAncho(childId);
                    
                    total += childWidth;
                    
                    // Agregar espaciado antes del siguiente hermano
                    if (i < p.hijos.length - 1) {
                        const nextChildId = p.hijos[i + 1];
                        const nextChild = personas.find(n => n.id === nextChildId);
                        
                        // Si el hijo actual tiene descendientes Y el siguiente NO tiene hijos
                        // usar espacio compacto para permitir que el siguiente se "meta" en el espacio
                        if (child && child.hijos.length > 0 && nextChild && nextChild.hijos.length === 0) {
                            total += H_SPACING_COMPACT;
                        } else {
                            total += H_SPACING;
                        }
                    }
                }
                
                return Math.max(total, NODE_WIDTH);
            }
            
            // Posicionar nodos
            function posicionar(id, xStart, depth = 0) {
                const p = personas.find(n => n.id === id);
                if (!p) return;
                
                depthMap[id] = depth;
                const y = depth * (NODE_HEIGHT + V_GAP) + 50; // Y provisional (se recalcula con alturas reales)
                
                // Si es hoja (sin hijos)
                if (p.hijos.length === 0) {
                    layout[id] = { x: xStart, y: y };
                    return;
                }
                
                // Posicionar hijos uno por uno
                let currentX = xStart;
                
                for (let i = 0; i < p.hijos.length; i++) {
                    const childId = p.hijos[i];
                    const child = personas.find(n => n.id === childId);
                    
                    posicionar(childId, currentX, depth + 1);
                    
                    // Calcular posici√≥n para el siguiente hermano
                    if (i < p.hijos.length - 1) {
                        const nextChildId = p.hijos[i + 1];
                        const nextChild = personas.find(n => n.id === nextChildId);
                        
                        // ESTRATEGIA MEJORADA: Reducir gaps bas√°ndose en el √∫ltimo hijo
                        if (child && child.hijos.length > 0 && nextChild && nextChild.hijos.length > 0) {
                            // Ambos hermanos tienen hijos: posicionar basado en el √∫ltimo hijo
                            const lastChildOfCurrent = child.hijos[child.hijos.length - 1];
                            const lastChildPos = layout[lastChildOfCurrent];
                            
                            if (lastChildPos) {
                                currentX = lastChildPos.x + NODE_WIDTH + H_SPACING_SIBLINGS;
                            } else {
                                currentX = layout[childId].x + NODE_WIDTH + H_SPACING_SIBLINGS;
                            }
                        } else if (child && child.hijos.length > 0 && nextChild && nextChild.hijos.length === 0) {
                            // Hermano actual tiene hijos, siguiente no: compactar
                            currentX = layout[childId].x + NODE_WIDTH + H_SPACING_SIBLINGS;
                        } else {
                            // Caso normal: ninguno o solo el siguiente tiene hijos
                            const childWidth = calcularAncho(childId);
                            currentX += childWidth + H_SPACING;
                        }
                    }
                }
                
                // Centrar el padre sobre sus hijos
                let sumCentros = 0;
                p.hijos.forEach(childId => {
                    const childCentro = layout[childId].x + NODE_WIDTH / 2;
                    sumCentros += childCentro;
                });
                
                const centroPromedio = sumCentros / p.hijos.length;
                layout[id] = {
                    x: centroPromedio - NODE_WIDTH / 2,
                    y: y
                };
            }
            
            posicionar(raiz.id, 0, 0);

            // PASO EXTRA (V2.9.9): Resolver solapamientos horizontales de forma robusta
            // Estrategia: detectar colisiones por nivel y desplazar sub√°rboles completos, manteniendo centrado.
            function buildChildrenMap() {
                const m = {};
                personas.forEach(p => { m[p.id] = (p.hijos || []).slice(); });
                return m;
            }

            const childrenMap = buildChildrenMap();

            function collectSubtreeIds(rootId) {
                const out = [];
                const stack = [rootId];
                const seen = new Set();
                while (stack.length) {
                    const id = stack.pop();
                    if (seen.has(id)) continue;
                    seen.add(id);
                    out.push(id);
                    const kids = childrenMap[id] || [];
                    for (let i = kids.length - 1; i >= 0; i--) stack.push(kids[i]);
                }
                return out;
            }

            function shiftSubtree(rootId, dx) {
                if (!dx) return;
                const ids = collectSubtreeIds(rootId);
                ids.forEach(id => {
                    if (layout[id]) layout[id].x += dx;
                });
            }

            function recenterParentsPostorder(rootId) {
                // Recalcula x de cada padre como el promedio del centro de sus hijos.
                const post = [];
                const stack = [rootId];
                const seen = new Set();
                while (stack.length) {
                    const id = stack.pop();
                    if (seen.has(id)) continue;
                    seen.add(id);
                    post.push(id);
                    (childrenMap[id] || []).forEach(k => stack.push(k));
                }
                // Postorder real
                for (let i = post.length - 1; i >= 0; i--) {
                    const id = post[i];
                    const kids = childrenMap[id] || [];
                    if (!kids.length) continue;
                    let sum = 0;
                    kids.forEach(k => {
                        if (!layout[k]) return;
                        sum += layout[k].x + NODE_WIDTH / 2;
                    });
                    const avg = sum / kids.length;
                    if (layout[id]) layout[id].x = avg - NODE_WIDTH / 2;
                }
            }

            function resolveOverlaps(rootId) {
                const minGap = Math.max(H_SPACING, 10); // separaci√≥n m√≠nima entre nodos
                // Iteramos varias pasadas: resolver colisiones y luego recentrar padres.
                for (let pass = 0; pass < 8; pass++) {
                    // Agrupar por depth
                    const byDepth = {};
                    Object.keys(layout).forEach(idStr => {
                        const id = Number(idStr);
                        const d = depthMap[id] ?? 0;
                        (byDepth[d] ||= []).push(id);
                    });

                    let moved = 0;
                    const depths = Object.keys(byDepth).map(Number).sort((a,b)=>a-b);
                    for (const d of depths) {
                        const ids = byDepth[d].slice().sort((a,b)=>layout[a].x - layout[b].x);
                        for (let i = 0; i < ids.length - 1; i++) {
                            const a = ids[i];
                            const b = ids[i+1];
                            const aRight = layout[a].x + NODE_WIDTH;
                            const bLeft = layout[b].x;
                            const needed = aRight + minGap;
                            if (bLeft < needed) {
                                const dx = needed - bLeft;
                                shiftSubtree(b, dx);
                                moved += dx;
                                // actualizar bLeft para siguientes comparaciones
                                ids.slice(i+1).forEach(id => { /* nada: se recalcula por layout */ });
                            }
                        }
                    }

                    // Recentrar padres (solo el nodo del padre) para est√©tica centrada
                    recenterParentsPostorder(rootId);

                    if (moved === 0) break;
                }
            }

            resolveOverlaps(raiz.id);

            
            // Centrar el √°rbol horizontalmente
            let minX = Infinity;
            let maxX = -Infinity;
            
            Object.values(layout).forEach(pos => {
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x + NODE_WIDTH);
            });
            
            // Normalizar posiciones para que empiecen en 0
            const offsetX = -minX + MARGIN;
            
            // Dibujar nodos
            const drawnNodes = {};
            
            function draw(id) {
                const p = personas.find(n => n.id === id);
                if (!p || drawnNodes[id]) return;
                
                const pos = layout[id];
                const x = pos.x + offsetX;
                const y = pos.y;
                
                // Crear nodo
                const node = document.createElement('div');
                node.className = 'tree-node';
                node.style.left = x + 'px';
                node.style.top = y + 'px';
                node.setAttribute('data-id', id);
                
                let html = `<div class="tree-node-name">${p.nombre}</div>`;
                
                if (p.fechaNac || p.lugarNac) {
                    html += `<div class="tree-node-detail">üìÖ Nac: ${p.fechaNac || ''}${p.lugarNac ? ', ' + p.lugarNac : ''}</div>`;
                }
                
                p.matrimonios.forEach(mat => {
                    if (mat.fecha || mat.nombreConyuge) {
                        html += `<div class="tree-node-detail">üíç Mat: ${mat.fecha || ''}${mat.nombreConyuge ? ' con ' + mat.nombreConyuge : ''}</div>`;
                    }
                });
                
                if (p.fechaDef) {
                    html += `<div class="tree-node-detail">‚úùÔ∏è Def: ${p.fechaDef}</div>`;
                }
                
                node.innerHTML = html;
                canvasInner.appendChild(node);
                drawnNodes[id] = node;
                
                // Dibujar hijos
                p.hijos.forEach(childId => {
                    draw(childId);
                });
            }
            
            draw(raiz.id);
            // PASO 2: Medir alturas reales y recalcular Y por nivel (sin cambiar la l√≥gica general de X)
            requestAnimationFrame(() => {
                // 2.1 Medir altura m√°xima por nivel
                const maxHeightByDepth = {};
                let maxDepth = 0;
                Object.entries(drawnNodes).forEach(([nodeId, nodeEl]) => {
                    const d = depthMap[nodeId] ?? 0;
                    maxDepth = Math.max(maxDepth, d);
                    const h = nodeEl.offsetHeight;
                    maxHeightByDepth[d] = Math.max(maxHeightByDepth[d] || 0, h);
                });

                // 2.2 Calcular Y acumulado por nivel
                const yByDepth = {};
                let yCursor = 50;
                for (let d = 0; d <= maxDepth; d++) {
                    yByDepth[d] = yCursor;
                    const levelH = maxHeightByDepth[d] || NODE_HEIGHT;
                    yCursor += levelH + V_GAP;
                }

                // 2.3 Reposicionar nodos con el Y real
                Object.entries(drawnNodes).forEach(([nodeId, nodeEl]) => {
                    const d = depthMap[nodeId] ?? 0;
                    const newY = yByDepth[d];
                    nodeEl.style.top = newY + 'px';
                    if (layout[nodeId]) layout[nodeId].y = newY;
                });

                // PASO 3: Redibujar l√≠neas con las posiciones/alturas reales
                svg.innerHTML = '';

                function drawLines(id) {
                    const p = personas.find(n => n.id === id);
                    if (!p) return;

                    const parentNode = drawnNodes[id];
                    if (!parentNode) return;

                    const parentX = parseInt(parentNode.style.left);
                    const parentY = parseInt(parentNode.style.top);
                    const parentWidth = parentNode.offsetWidth;
                    const parentHeight = parentNode.offsetHeight;

                    p.hijos.forEach(childId => {
                        const childNode = drawnNodes[childId];
                        if (!childNode) return;

                        const childX = parseInt(childNode.style.left);
                        const childY = parseInt(childNode.style.top);
                        const childWidth = childNode.offsetWidth;

                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', parentX + parentWidth / 2);
                        line.setAttribute('y1', parentY + parentHeight);
                        line.setAttribute('x2', childX + childWidth / 2);
                        line.setAttribute('y2', childY);
                        line.setAttribute('stroke', '#34495e');
                        line.setAttribute('stroke-width', '2');
                        svg.appendChild(line);

                        drawLines(childId);
                    });
                }

                drawLines(raiz.id);

                // PASO 4: Ajustar tama√±o del SVG y del contenedor interno
                let maxXCanvas = 0, maxYCanvas = 0;
                Object.values(drawnNodes).forEach(node => {
                    const right = node.offsetLeft + node.offsetWidth;
                    const bottom = node.offsetTop + node.offsetHeight;
                    maxXCanvas = Math.max(maxXCanvas, right);
                    maxYCanvas = Math.max(maxYCanvas, bottom);
                });

                const treeWidth = maxXCanvas + MARGIN;
                const treeHeight = maxYCanvas + 100;

                svg.setAttribute('width', treeWidth);
                svg.setAttribute('height', treeHeight);
                canvasInner.style.width = treeWidth + 'px';
                canvasInner.style.height = treeHeight + 'px';

                // PASO 5: ZOOM autom√°tico
                const containerWidth = canvas.clientWidth;
                const containerHeight = canvas.clientHeight;

                const scaleX = containerWidth / treeWidth;
                const scaleY = containerHeight / treeHeight;
                const scale = Math.min(scaleX, scaleY, 1);

                canvasInner.style.transform = `translate(-50%, -50%) scale(${scale})`;

                console.log(`√Årbol (din√°mico Y): ${treeWidth}x${treeHeight}px, Contenedor: ${containerWidth}x${containerHeight}px, Escala: ${(scale * 100).toFixed(0)}%`);
            });

            console.log('√Årbol dibujado, nodos:', Object.keys(drawnNodes).length);
        }

        function clearAll() {
            if (confirm('¬øEst√°s seguro de limpiar todo?')) {
                personas = [];
                nextId = 1;
                nextMatrimonioId = 1; // V2.9.4: Resetear contador de matrimonios
                document.getElementById('matrimoniosContainer').innerHTML = ''; // V2.9.4: Limpiar matrimonios din√°micos
                updatePersonList();
                updateRelacionSelect();
                updateRelacionOptions(); // V1.2: Actualizar estado de opciones de relaci√≥n
                drawTree();
            }
        }
        
        function exportToPDF() {
            const canvasInner = document.getElementById('treeCanvasInner');
            
            if (personas.length === 0) {
                alert('No hay personas en el √°rbol para exportar');
                return;
            }
            
            // Guardar estado original
            const originalTransform = canvasInner.style.transform;
            
            // Resetear a escala 1 manteniendo centrado
            canvasInner.style.transform = 'translate(-50%, -50%) scale(1)';
            
            setTimeout(() => {
                // Obtener dimensiones reales del √°rbol
                const treeWidth = parseInt(canvasInner.style.width) || 0;
                const treeHeight = parseInt(canvasInner.style.height) || 0;
                
                // √Årea de impresi√≥n M√ÅXIMA con m√°rgenes reducidos
                // A4 landscape: 297√ó210mm = ~1123√ó794px @ 96dpi
                // Letter landscape: 279√ó216mm = ~1056√ó816px @ 96dpi
                // M√°rgenes m√≠nimos (~30px horizontal, ~28px vertical por lado)
                // OBJETIVO: Aprovechar al M√ÅXIMO el espacio disponible
                const maxPrintWidth = 1060;  // M√°rgenes reducidos 50%
                const maxPrintHeight = 740;  // M√°rgenes reducidos 50%
                
                // Calcular escala para LLENAR el √°rea disponible
                const scaleX = maxPrintWidth / treeWidth;
                const scaleY = maxPrintHeight / treeHeight;
                const scale = Math.min(scaleX, scaleY, 1); // Usa el menor para que quepa, pero nunca agrandar
                
                // Aplicar escala con centrado manual
                canvasInner.style.transform = `translate(-50%, -50%) scale(${scale})`;
                
                console.log('Exportando PDF:');
                console.log(`  √Årbol original: ${treeWidth}√ó${treeHeight}px`);
                console.log(`  √Årea de impresi√≥n disponible: ${maxPrintWidth}√ó${maxPrintHeight}px`);
                console.log(`  Escala aplicada: ${(scale * 100).toFixed(0)}%`);
                console.log(`  Tama√±o final: ${(treeWidth * scale).toFixed(0)}√ó${(treeHeight * scale).toFixed(0)}px`);
                console.log(`  ‚úì √Årbol escalado para llenar el √°rea de impresi√≥n`);
                console.log(`  ‚úì Centrado manual (position: absolute + translate)`);
                console.log(`  ‚Ñπ Recomendaci√≥n: Usar orientaci√≥n HORIZONTAL (landscape)`);
                
                // Imprimir
                setTimeout(() => {
                    window.print();
                    
                    // Restaurar estado original
                    setTimeout(() => {
                        canvasInner.style.transform = originalTransform;
                    }, 100);
                }, 100);
            }, 50);
        }
        
        // V1.2: Inicializar estado de opciones de relaci√≥n al cargar la p√°gina
        updateRelacionOptions();
    </script>
</body>
</html>
